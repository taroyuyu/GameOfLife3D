/** \file
 *  This C source file was generated by $ANTLR version 3.3 Nov 30, 2010 12:45:30
 *
 *     -  From the grammar source file : ColorSetDef.g
 *     -                            On : 2011-02-27 23:08:07
 *     -                 for the lexer : ColorSetDefLexerLexer *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

// @lexer::header
#define ANTLR3_INLINE_INPUT_UTF16

#include "graphics/color/colorsetdef/ColorSetDef.h"
using namespace graphics::color;

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "ColorSetDefLexer.h"
/* ----------------------------------------- */


/** String literals used by ColorSetDefLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR lit_1[]  = { 0x73, 0x6F, 0x6C, 0x69, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_2[]  = { 0x6C, 0x69, 0x6E, 0x65, 0x61, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_3[]  = { 0x54, 0x4F, 0x50, 0x5F, 0x42, 0x4F, 0x54, 0x54, 0x4F, 0x4D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_4[]  = { 0x54, 0x4F, 0x50, 0x4C, 0x45, 0x46, 0x54, 0x5F, 0x42, 0x4F, 0x54, 0x54, 0x4F, 0x4D, 0x52, 0x49, 0x47, 0x48, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_5[]  = { 0x72, 0x61, 0x64, 0x69, 0x61, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_6[]  = { 0x72, 0x67, 0x62, 0x61, 0x28,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_7[]  = { 0x68, 0x73, 0x62, 0x61, 0x28,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_8[]  = { 0x30, 0x78,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_9[]  = { 0x2F, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_10[]  = { 0x2F, 0x2A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_11[]  = { 0x2A, 0x2F,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define     CTX ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef  SCOPE_TYPE
#undef  SCOPE_STACK
#undef  SCOPE_TOP
#define SCOPE_TYPE(scope)   pColorSetDefLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pColorSetDefLexer_##scope##Stack
#define SCOPE_TOP(scope)    ctx->pColorSetDefLexer_##scope##Top
#define SCOPE_SIZE(scope)       ctx->pColorSetDefLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)    (ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))


/* Macros for accessing things in a lexer
 */
#undef      LEXER
#undef      RECOGNIZER
#undef      RULEMEMO
#undef      GETCHARINDEX
#undef      GETLINE
#undef      GETCHARPOSITIONINLINE
#undef      EMIT
#undef      EMITNEW
#undef      MATCHC
#undef      MATCHS
#undef      MATCHRANGE
#undef      LTOKEN
#undef      HASFAILED
#undef      FAILEDFLAG
#undef      INPUT
#undef      STRSTREAM
#undef      LA
#undef      HASEXCEPTION
#undef      EXCEPTION
#undef      CONSTRUCTEX
#undef      CONSUME
#undef      LRECOVER
#undef      MARK
#undef      REWIND
#undef      REWINDLAST
#undef      BACKTRACKING
#undef      MATCHANY
#undef      MEMOIZE
#undef      HAVEPARSEDRULE
#undef      GETTEXT
#undef      INDEX
#undef      SEEK
#undef      PUSHSTREAM
#undef      POPSTREAM
#undef      SETTEXT
#undef      SETTEXT8

#define     LEXER                   ctx->pLexer
#define     RECOGNIZER              LEXER->rec
#define     LEXSTATE                RECOGNIZER->state
#define     TOKSOURCE               LEXSTATE->tokSource
#define     GETCHARINDEX()          LEXER->getCharIndex(LEXER)
#define     GETLINE()               LEXER->getLine(LEXER)
#define     GETTEXT()               LEXER->getText(LEXER)
#define     GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define     EMIT()                  LEXSTATE->type = _type; LEXER->emit(LEXER)
#define     EMITNEW(t)              LEXER->emitNew(LEXER, t)
#define     MATCHC(c)               LEXER->matchc(LEXER, c)
#define     MATCHS(s)               LEXER->matchs(LEXER, s)
#define     MATCHRANGE(c1,c2)       LEXER->matchRange(LEXER, c1, c2)
#define     MATCHANY()              LEXER->matchAny(LEXER)
#define     LTOKEN                  LEXSTATE->token
#define     HASFAILED()             (LEXSTATE->failed == ANTLR3_TRUE)
#define     BACKTRACKING            LEXSTATE->backtracking
#define     FAILEDFLAG              LEXSTATE->failed
#define     INPUT                   LEXER->input
#define     STRSTREAM               INPUT
#define     ISTREAM                 INPUT->istream
#define     INDEX()                 ISTREAM->index(ISTREAM)
#define     SEEK(n)                 ISTREAM->seek(ISTREAM, n)
#define     EOF_TOKEN               &(LEXSTATE->tokSource->eofToken)
#define     HASEXCEPTION()          (LEXSTATE->error == ANTLR3_TRUE)
#define     EXCEPTION               LEXSTATE->exception
#define     CONSTRUCTEX()           RECOGNIZER->exConstruct(RECOGNIZER)
#define     LRECOVER()              LEXER->recover(LEXER)
#define     MARK()                  ISTREAM->mark(ISTREAM)
#define     REWIND(m)               ISTREAM->rewind(ISTREAM, m)
#define     REWINDLAST()            ISTREAM->rewindLast(ISTREAM)
#define     MEMOIZE(ri,si)          RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define     HAVEPARSEDRULE(r)       RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define     PUSHSTREAM(str)         LEXER->pushCharStream(LEXER, str)
#define     POPSTREAM()             LEXER->popCharStream(LEXER)
#define     SETTEXT(str)            LEXSTATE->text = str
#define     SKIP()                  LEXSTATE->token = &(TOKSOURCE->skipToken)
#define     USER1                   LEXSTATE->user1
#define     USER2                   LEXSTATE->user2
#define     USER3                   LEXSTATE->user3
#define     CUSTOM                  LEXSTATE->custom
#define     RULEMEMO                LEXSTATE->ruleMemo
#define     DBG                     RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or UTF16 input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if defined(ANTLR3_INLINE_INPUT_8BIT) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef ANTLR3_INLINE_INPUT_8BIT

/* 8 bit character set */

#  define       NEXTCHAR    ((pANTLR3_UINT8)(INPUT->nextChar))
#  define       DATAP   ((pANTLR3_UINT8)(INPUT->data))

# else

#  define       NEXTCHAR    ((pANTLR3_UINT16)(INPUT->nextChar))
#  define       DATAP   ((pANTLR3_UINT16)(INPUT->data))

# endif

# define        LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define            CONSUME()                                           \
{                                                                       \
    if        (NEXTCHAR < (DATAP + INPUT->sizeBuf))                     \
    {                                                                   \
        INPUT->charPositionInLine++;                                    \
        if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)           \
        {                                                               \
            INPUT->line++;                                              \
            INPUT->charPositionInLine        = 0;                       \
            INPUT->currentLine                = (void *)(NEXTCHAR + 1); \
        }                                                               \
        INPUT->nextChar = (void *)(NEXTCHAR + 1);                       \
    }                                                                   \
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define     CONSUME()   INPUT->istream->consume(INPUT->istream)
#define     LA(n)       INPUT->istream->_LA(INPUT->istream, n)

#endif
#define     TOKTEXT(tok, txt)               tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define     UP      ANTLR3_TOKEN_UP
#define     DOWN    ANTLR3_TOKEN_DOWN
#define     EOR     ANTLR3_TOKEN_EOR
#define     INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void  mT__16    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__17    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__18    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__19    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__20    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__21    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__22    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__23    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__24    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__25    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__26    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__27    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mT__28    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mID    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mINT    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mHEXINT    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mFLOAT    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mCOMMENT    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mWS    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mSTRING    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mEXPONENT    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mHEX_DIGIT    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mESC_SEQ    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mOCTAL_ESC    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mUNICODE_ESC    (pColorSetDefLexer ctx);
static ANTLR3_INLINE  void  mTokens    (pColorSetDefLexer ctx);
static void ColorSetDefLexerFree(pColorSetDefLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
ColorSetDefLexerFree  (pColorSetDefLexer ctx)
{
    LEXER->free(LEXER);

    ANTLR3_FREE(ctx);
}

static void
ColorSetDefLexerReset (pColorSetDefLexer ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "ColorSetDef.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
    return fileName;
}

/** \brief Create a new lexer called ColorSetDefLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pColorSetDefLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pColorSetDefLexer ColorSetDefLexerNew
(pANTLR3_INPUT_STREAM instream)
{
    // See if we can create a new lexer with the standard constructor
    //
    return ColorSetDefLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called ColorSetDefLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pColorSetDefLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pColorSetDefLexer ColorSetDefLexerNewSSD
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pColorSetDefLexer ctx; // Context structure we will build and return

    ctx = (pColorSetDefLexer) ANTLR3_CALLOC(1, sizeof(ColorSetDefLexer));

    if  (ctx == NULL) {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in ColorSetDefLexer.h here so you can get a sense
     * of what goes where.
     */

    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer = antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Check that we allocated the memory correctly
     */
    if  (ctx->pLexer == NULL) {
        ANTLR3_FREE(ctx);
        return  NULL;
    }
    /* Install the implementation of our ColorSetDefLexer interface
     */
    ctx->mT__16 = mT__16;
    ctx->mT__17 = mT__17;
    ctx->mT__18 = mT__18;
    ctx->mT__19 = mT__19;
    ctx->mT__20 = mT__20;
    ctx->mT__21 = mT__21;
    ctx->mT__22 = mT__22;
    ctx->mT__23 = mT__23;
    ctx->mT__24 = mT__24;
    ctx->mT__25 = mT__25;
    ctx->mT__26 = mT__26;
    ctx->mT__27 = mT__27;
    ctx->mT__28 = mT__28;
    ctx->mID    = mID;
    ctx->mINT   = mINT;
    ctx->mHEXINT    = mHEXINT;
    ctx->mFLOAT = mFLOAT;
    ctx->mCOMMENT   = mCOMMENT;
    ctx->mWS    = mWS;
    ctx->mSTRING    = mSTRING;
    ctx->mEXPONENT  = mEXPONENT;
    ctx->mHEX_DIGIT = mHEX_DIGIT;
    ctx->mESC_SEQ   = mESC_SEQ;
    ctx->mOCTAL_ESC = mOCTAL_ESC;
    ctx->mUNICODE_ESC   = mUNICODE_ESC;
    ctx->mTokens    = mTokens;

    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx        = ctx;

    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);

    ctx->getGrammarFileName = getGrammarFileName;
    ctx->free       = ColorSetDefLexerFree;
    ctx->reset          = ColorSetDefLexerReset;





    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    126:1: FLOAT : ( ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | ( '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '-' )? ( '0' .. '9' )+ EXPONENT );
 */
static const ANTLR3_INT32 dfa14_eot[6] = {
    -1, -1, -1, -1, -1, -1
};
static const ANTLR3_INT32 dfa14_eof[6] = {
    -1, -1, -1, -1, -1, -1
};
static const ANTLR3_INT32 dfa14_min[6] = {
    45, 46, 46, -1, -1, -1
};
static const ANTLR3_INT32 dfa14_max[6] = {
    57, 57, 101, -1, -1, -1
};
static const ANTLR3_INT32 dfa14_accept[6] = {
    -1, -1, -1, 2, 1, 3
};
static const ANTLR3_INT32 dfa14_special[6] = {
    -1, -1, -1, -1, -1, -1
};

/** Used when there is no transition table entry for a particular state */
#define dfa14_T_empty       NULL

static const ANTLR3_INT32 dfa14_T0[] = {
    1, 3, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
};
static const ANTLR3_INT32 dfa14_T1[] = {
    3, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
};
static const ANTLR3_INT32 dfa14_T2[] = {
    4, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5
};

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa14_transitions[] = {
    dfa14_T0, dfa14_T1, dfa14_T2, dfa14_T_empty, dfa14_T_empty, dfa14_T_empty
};


/* Declare tracking structure for Cyclic DFA 14
 */
static
ANTLR3_CYCLIC_DFA cdfa14
=   {
    14,         /* Decision number of this dfa      */
    /* Which decision this represents:   */
    (const pANTLR3_UCHAR)"126:1: FLOAT : ( ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | ( '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '-' )? ( '0' .. '9' )+ EXPONENT );",
    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,    /* Default special state transition function    */
    antlr3dfaspecialTransition,     /* DFA specialTransition is currently just a default function in the runtime */
    antlr3dfapredict,           /* DFA simulator function is in the runtime */
    dfa14_eot,      /* EOT table                */
    dfa14_eof,      /* EOF table                */
    dfa14_min,      /* Minimum tokens for each state    */
    dfa14_max,      /* Maximum tokens for each state    */
    dfa14_accept,   /* Accept table             */
    dfa14_special,  /* Special transition states        */
    dfa14_transitions   /* Table of transition tables       */

};
/* End of Cyclic DFA 14
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | ID | INT | HEXINT | FLOAT | COMMENT | WS | STRING );
 */
static const ANTLR3_INT32 dfa24_eot[73] = {
    -1, -1, 12, -1, -1, -1, -1, 12, 12, -1, 12, 12, -1, 26, 26, -1, -1, -1,
    -1, -1, 12, 12, 12, 12, 12, 12, -1, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 47, 12, 12, 12, 12, -1, -1, -1, 52, 12, 12, 55, -1, 12,
    12, -1, 12, 12, 12, 12, 62, 12, -1, 12, 12, 12, 12, 12, 12, 12, 12, 72,
    -1
};
static const ANTLR3_INT32 dfa24_eof[73] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1
};
static const ANTLR3_INT32 dfa24_min[73] = {
    9, -1, 111, -1, -1, -1, -1, 105, 79, -1, 97, 115, -1, 46, 46, -1, -1,
    -1, -1, -1, 108, 110, 80, 100, 98, 98, -1, 105, 101, 76, 105, 97, 97, 100,
    97, 66, 69, 97, 40, 40, 48, 114, 79, 70, 108, -1, -1, -1, 48, 84, 84, 48,
    -1, 84, 95, -1, 79, 66, 77, 79, 48, 84, -1, 84, 79, 77, 82, 73, 71, 72,
    84, 48, -1
};
static const ANTLR3_INT32 dfa24_max[73] = {
    122, -1, 111, -1, -1, -1, -1, 105, 79, -1, 103, 115, -1, 120, 101, -1,
    -1, -1, -1, -1, 108, 110, 80, 100, 98, 98, -1, 105, 101, 95, 105, 97, 97,
    100, 97, 66, 69, 97, 40, 40, 122, 114, 79, 70, 108, -1, -1, -1, 122, 84,
    84, 122, -1, 84, 95, -1, 79, 66, 77, 79, 122, 84, -1, 84, 79, 77, 82, 73,
    71, 72, 84, 122, -1
};
static const ANTLR3_INT32 dfa24_accept[73] = {
    -1, 1, -1, 3, 4, 5, 6, -1, -1, 10, -1, -1, 14, -1, -1, 16, 17, 18, 19,
    20, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, 12, 13, 2, -1, -1, -1, -1, 7, -1, -1, 11,
    -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9
};
static const ANTLR3_INT32 dfa24_special[73] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1
};

/** Used when there is no transition table entry for a particular state */
#define dfa24_T_empty       NULL

static const ANTLR3_INT32 dfa24_T0[] = {
    20
};
static const ANTLR3_INT32 dfa24_T1[] = {
    43
};
static const ANTLR3_INT32 dfa24_T2[] = {
    50
};
static const ANTLR3_INT32 dfa24_T3[] = {
    16, -1, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, 16
};
static const ANTLR3_INT32 dfa24_T4[] = {
    49
};
static const ANTLR3_INT32 dfa24_T5[] = {
    53
};
static const ANTLR3_INT32 dfa24_T6[] = {
    42
};
static const ANTLR3_INT32 dfa24_T7[] = {
    60
};
static const ANTLR3_INT32 dfa24_T8[] = {
    56
};
static const ANTLR3_INT32 dfa24_T9[] = {
    58
};
static const ANTLR3_INT32 dfa24_T10[] = {
    70
};
static const ANTLR3_INT32 dfa24_T11[] = {
    69
};
static const ANTLR3_INT32 dfa24_T12[] = {
    68
};
static const ANTLR3_INT32 dfa24_T13[] = {
    67
};
static const ANTLR3_INT32 dfa24_T14[] = {
    22
};
static const ANTLR3_INT32 dfa24_T15[] = {
    71
};
static const ANTLR3_INT32 dfa24_T16[] = {
    61
};
static const ANTLR3_INT32 dfa24_T17[] = {
    59
};
static const ANTLR3_INT32 dfa24_T18[] = {
    57
};
static const ANTLR3_INT32 dfa24_T19[] = {
    54
};
static const ANTLR3_INT32 dfa24_T20[] = {
    66
};
static const ANTLR3_INT32 dfa24_T21[] = {
    65
};
static const ANTLR3_INT32 dfa24_T22[] = {
    64
};
static const ANTLR3_INT32 dfa24_T23[] = {
    63
};
static const ANTLR3_INT32 dfa24_T24[] = {
    25
};
static const ANTLR3_INT32 dfa24_T25[] = {
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, -1, -1, -1, -1, -1, -1, -1, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, -1, -1, -1, -1, 12, -1, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12
};
static const ANTLR3_INT32 dfa24_T26[] = {
    40
};
static const ANTLR3_INT32 dfa24_T27[] = {
    29
};
static const ANTLR3_INT32 dfa24_T28[] = {
    36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, 35
};
static const ANTLR3_INT32 dfa24_T29[] = {
    48
};
static const ANTLR3_INT32 dfa24_T30[] = {
    41
};
static const ANTLR3_INT32 dfa24_T31[] = {
    16, -1, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, 15
};
static const ANTLR3_INT32 dfa24_T32[] = {
    34
};
static const ANTLR3_INT32 dfa24_T33[] = {
    28
};
static const ANTLR3_INT32 dfa24_T34[] = {
    18, 18, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, 18, -1, -1, 15, -1, -1, -1, 19, 5, 6, -1, -1, 1, 16,
    16, 17, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, -1, -1, -1, -1, -1, -1,
    9, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 8, 12, 12, 12, 12, 12, 12, 3, -1, 4, -1, 12, -1, 12, 12, 12, 12,
    12, 12, 12, 11, 12, 12, 12, 7, 12, 12, 12, 12, 12, 10, 2, 12, 12, 12, 12,
    12, 12, 12
};
static const ANTLR3_INT32 dfa24_T35[] = {
    33
};
static const ANTLR3_INT32 dfa24_T36[] = {
    27
};
static const ANTLR3_INT32 dfa24_T37[] = {
    23, -1, -1, -1, -1, -1, 24
};
static const ANTLR3_INT32 dfa24_T38[] = {
    37
};
static const ANTLR3_INT32 dfa24_T39[] = {
    30
};
static const ANTLR3_INT32 dfa24_T40[] = {
    21
};
static const ANTLR3_INT32 dfa24_T41[] = {
    31
};
static const ANTLR3_INT32 dfa24_T42[] = {
    51
};
static const ANTLR3_INT32 dfa24_T43[] = {
    44
};
static const ANTLR3_INT32 dfa24_T44[] = {
    32
};
static const ANTLR3_INT32 dfa24_T45[] = {
    38
};
static const ANTLR3_INT32 dfa24_T46[] = {
    45
};
static const ANTLR3_INT32 dfa24_T47[] = {
    39
};
static const ANTLR3_INT32 dfa24_T48[] = {
    46
};

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa24_transitions[] = {
    dfa24_T34, dfa24_T_empty, dfa24_T0, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty,
    dfa24_T_empty, dfa24_T40, dfa24_T14, dfa24_T_empty, dfa24_T37, dfa24_T24,
    dfa24_T_empty, dfa24_T31, dfa24_T3, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty,
    dfa24_T_empty, dfa24_T_empty, dfa24_T36, dfa24_T33, dfa24_T27, dfa24_T39,
    dfa24_T41, dfa24_T44, dfa24_T_empty, dfa24_T35, dfa24_T32, dfa24_T28,
    dfa24_T38, dfa24_T45, dfa24_T47, dfa24_T26, dfa24_T30, dfa24_T6, dfa24_T1,
    dfa24_T43, dfa24_T46, dfa24_T48, dfa24_T25, dfa24_T29, dfa24_T4, dfa24_T2,
    dfa24_T42, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T25, dfa24_T5,
    dfa24_T19, dfa24_T25, dfa24_T_empty, dfa24_T8, dfa24_T18, dfa24_T_empty,
    dfa24_T9, dfa24_T17, dfa24_T7, dfa24_T16, dfa24_T25, dfa24_T23, dfa24_T_empty,
    dfa24_T22, dfa24_T21, dfa24_T20, dfa24_T13, dfa24_T12, dfa24_T11, dfa24_T10,
    dfa24_T15, dfa24_T25, dfa24_T_empty
};


/* Declare tracking structure for Cyclic DFA 24
 */
static
ANTLR3_CYCLIC_DFA cdfa24
=   {
    24,         /* Decision number of this dfa      */
    /* Which decision this represents:   */
    (const pANTLR3_UCHAR)"1:1: Tokens : ( T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | ID | INT | HEXINT | FLOAT | COMMENT | WS | STRING );",
    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,    /* Default special state transition function    */
    antlr3dfaspecialTransition,     /* DFA specialTransition is currently just a default function in the runtime */
    antlr3dfapredict,           /* DFA simulator function is in the runtime */
    dfa24_eot,      /* EOT table                */
    dfa24_eof,      /* EOF table                */
    dfa24_min,      /* Minimum tokens for each state    */
    dfa24_max,      /* Maximum tokens for each state    */
    dfa24_accept,   /* Accept table             */
    dfa24_special,  /* Special transition states        */
    dfa24_transitions   /* Table of transition tables       */

};
/* End of Cyclic DFA 24
 * ---------------------
 */
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 18:7: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__16
 *
 * Looks to match the characters the constitute the token T__16
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__16(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__16;


    // ColorSetDef.g:18:7: ( ',' )
    // ColorSetDef.g:18:9: ','
    {
        MATCHC(',');
        if  (HASEXCEPTION()) {
            goto ruleT__16Ex;
        }


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__16Ex; /* Prevent compiler warnings */
ruleT__16Ex:
    ;

}
// $ANTLR end T__16

//   Comes from: 19:7: ( 'solid' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__17
 *
 * Looks to match the characters the constitute the token T__17
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__17(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__17;


    // ColorSetDef.g:19:7: ( 'solid' )
    // ColorSetDef.g:19:9: 'solid'
    {
        MATCHS(lit_1);
        if  (HASEXCEPTION()) {
            goto ruleT__17Ex;
        }



    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__17Ex; /* Prevent compiler warnings */
ruleT__17Ex:
    ;

}
// $ANTLR end T__17

//   Comes from: 20:7: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__18
 *
 * Looks to match the characters the constitute the token T__18
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__18(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__18;


    // ColorSetDef.g:20:7: ( '[' )
    // ColorSetDef.g:20:9: '['
    {
        MATCHC('[');
        if  (HASEXCEPTION()) {
            goto ruleT__18Ex;
        }


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__18Ex; /* Prevent compiler warnings */
ruleT__18Ex:
    ;

}
// $ANTLR end T__18

//   Comes from: 21:7: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__19
 *
 * Looks to match the characters the constitute the token T__19
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__19(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__19;


    // ColorSetDef.g:21:7: ( ']' )
    // ColorSetDef.g:21:9: ']'
    {
        MATCHC(']');
        if  (HASEXCEPTION()) {
            goto ruleT__19Ex;
        }


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__19Ex; /* Prevent compiler warnings */
ruleT__19Ex:
    ;

}
// $ANTLR end T__19

//   Comes from: 22:7: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__20
 *
 * Looks to match the characters the constitute the token T__20
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__20(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__20;


    // ColorSetDef.g:22:7: ( '(' )
    // ColorSetDef.g:22:9: '('
    {
        MATCHC('(');
        if  (HASEXCEPTION()) {
            goto ruleT__20Ex;
        }


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__20Ex; /* Prevent compiler warnings */
ruleT__20Ex:
    ;

}
// $ANTLR end T__20

//   Comes from: 23:7: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__21
 *
 * Looks to match the characters the constitute the token T__21
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__21(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__21;


    // ColorSetDef.g:23:7: ( ')' )
    // ColorSetDef.g:23:9: ')'
    {
        MATCHC(')');
        if  (HASEXCEPTION()) {
            goto ruleT__21Ex;
        }


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__21Ex; /* Prevent compiler warnings */
ruleT__21Ex:
    ;

}
// $ANTLR end T__21

//   Comes from: 24:7: ( 'linear' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__22
 *
 * Looks to match the characters the constitute the token T__22
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__22(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__22;


    // ColorSetDef.g:24:7: ( 'linear' )
    // ColorSetDef.g:24:9: 'linear'
    {
        MATCHS(lit_2);
        if  (HASEXCEPTION()) {
            goto ruleT__22Ex;
        }



    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__22Ex; /* Prevent compiler warnings */
ruleT__22Ex:
    ;

}
// $ANTLR end T__22

//   Comes from: 25:7: ( 'TOP_BOTTOM' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__23
 *
 * Looks to match the characters the constitute the token T__23
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__23(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__23;


    // ColorSetDef.g:25:7: ( 'TOP_BOTTOM' )
    // ColorSetDef.g:25:9: 'TOP_BOTTOM'
    {
        MATCHS(lit_3);
        if  (HASEXCEPTION()) {
            goto ruleT__23Ex;
        }



    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__23Ex; /* Prevent compiler warnings */
ruleT__23Ex:
    ;

}
// $ANTLR end T__23

//   Comes from: 26:7: ( 'TOPLEFT_BOTTOMRIGHT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__24
 *
 * Looks to match the characters the constitute the token T__24
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__24(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__24;


    // ColorSetDef.g:26:7: ( 'TOPLEFT_BOTTOMRIGHT' )
    // ColorSetDef.g:26:9: 'TOPLEFT_BOTTOMRIGHT'
    {
        MATCHS(lit_4);
        if  (HASEXCEPTION()) {
            goto ruleT__24Ex;
        }



    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__24Ex; /* Prevent compiler warnings */
ruleT__24Ex:
    ;

}
// $ANTLR end T__24

//   Comes from: 27:7: ( '@' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__25
 *
 * Looks to match the characters the constitute the token T__25
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__25(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__25;


    // ColorSetDef.g:27:7: ( '@' )
    // ColorSetDef.g:27:9: '@'
    {
        MATCHC('@');
        if  (HASEXCEPTION()) {
            goto ruleT__25Ex;
        }


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__25Ex; /* Prevent compiler warnings */
ruleT__25Ex:
    ;

}
// $ANTLR end T__25

//   Comes from: 28:7: ( 'radial' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__26
 *
 * Looks to match the characters the constitute the token T__26
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__26(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__26;


    // ColorSetDef.g:28:7: ( 'radial' )
    // ColorSetDef.g:28:9: 'radial'
    {
        MATCHS(lit_5);
        if  (HASEXCEPTION()) {
            goto ruleT__26Ex;
        }



    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__26Ex; /* Prevent compiler warnings */
ruleT__26Ex:
    ;

}
// $ANTLR end T__26

//   Comes from: 29:7: ( 'rgba(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__27
 *
 * Looks to match the characters the constitute the token T__27
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__27(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__27;


    // ColorSetDef.g:29:7: ( 'rgba(' )
    // ColorSetDef.g:29:9: 'rgba('
    {
        MATCHS(lit_6);
        if  (HASEXCEPTION()) {
            goto ruleT__27Ex;
        }



    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__27Ex; /* Prevent compiler warnings */
ruleT__27Ex:
    ;

}
// $ANTLR end T__27

//   Comes from: 30:7: ( 'hsba(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__28
 *
 * Looks to match the characters the constitute the token T__28
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__28(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__28;


    // ColorSetDef.g:30:7: ( 'hsba(' )
    // ColorSetDef.g:30:9: 'hsba('
    {
        MATCHS(lit_7);
        if  (HASEXCEPTION()) {
            goto ruleT__28Ex;
        }



    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__28Ex; /* Prevent compiler warnings */
ruleT__28Ex:
    ;

}
// $ANTLR end T__28

//   Comes from: 118:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ID
 *
 * Looks to match the characters the constitute the token ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mID(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = ID;


    // ColorSetDef.g:118:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
    // ColorSetDef.g:118:7: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) ) {
            CONSUME();

        } else {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleIDEx;
        }


        // ColorSetDef.g:118:31: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*

        for (;;) {
            int alt1 = 2;
            switch ( LA(1) ) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z': {
                alt1 = 1;
            }
            break;

            }

            switch (alt1) {
            case 1:
                // ColorSetDef.g:
            {
                if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) ) {
                    CONSUME();

                } else {
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                    EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                    LRECOVER();
                    goto ruleIDEx;
                }


            }
            break;

            default:
                goto loop1; /* break out of the loop */
                break;
            }
        }
loop1: ; /* Jump out to here if this rule does not match */


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIDEx; /* Prevent compiler warnings */
ruleIDEx:
    ;

}
// $ANTLR end ID

//   Comes from: 121:5: ( ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INT
 *
 * Looks to match the characters the constitute the token INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINT(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = INT;


    // ColorSetDef.g:121:5: ( ( '0' .. '9' )+ )
    // ColorSetDef.g:121:7: ( '0' .. '9' )+
    {
        // ColorSetDef.g:121:7: ( '0' .. '9' )+
        {
            int cnt2 = 0;

            for (;;) {
                int alt2 = 2;
                switch ( LA(1) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                    alt2 = 1;
                }
                break;

                }

                switch (alt2) {
                case 1:
                    // ColorSetDef.g:121:7: '0' .. '9'
                {
                    MATCHRANGE('0', '9');
                    if  (HASEXCEPTION()) {
                        goto ruleINTEx;
                    }


                }
                break;

                default:

                    if ( cnt2 >= 1 ) {
                        goto loop2;
                    }
                    /* mismatchedSetEx()
                     */
                    CONSTRUCTEX();
                    EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                    EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                    goto ruleINTEx;
                }
                cnt2++;
            }
loop2: ;    /* Jump to here if this rule does not match */
        }

    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINTEx; /* Prevent compiler warnings */
ruleINTEx:
    ;

}
// $ANTLR end INT

//   Comes from: 124:9: ( ( '0x' | '#' ) ( HEX_DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEXINT
 *
 * Looks to match the characters the constitute the token HEXINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEXINT(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = HEXINT;


    // ColorSetDef.g:124:9: ( ( '0x' | '#' ) ( HEX_DIGIT )+ )
    // ColorSetDef.g:124:11: ( '0x' | '#' ) ( HEX_DIGIT )+
    {

        // ColorSetDef.g:124:11: ( '0x' | '#' )
        {
            int alt3 = 2;
            switch ( LA(1) ) {
            case '0': {
                alt3 = 1;
            }
            break;
            case '#': {
                alt3 = 2;
            }
            break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto ruleHEXINTEx;
            }

            switch (alt3) {
            case 1:
                // ColorSetDef.g:124:12: '0x'
            {
                MATCHS(lit_8);
                if  (HASEXCEPTION()) {
                    goto ruleHEXINTEx;
                }



            }
            break;
            case 2:
                // ColorSetDef.g:124:19: '#'
            {
                MATCHC('#');
                if  (HASEXCEPTION()) {
                    goto ruleHEXINTEx;
                }


            }
            break;

            }
        }
        // ColorSetDef.g:124:24: ( HEX_DIGIT )+
        {
            int cnt4 = 0;

            for (;;) {
                int alt4 = 2;
                switch ( LA(1) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f': {
                    alt4 = 1;
                }
                break;

                }

                switch (alt4) {
                case 1:
                    // ColorSetDef.g:124:24: HEX_DIGIT
                {
                    /* 124:24: HEX_DIGIT */
                    mHEX_DIGIT(ctx );
                    if  (HASEXCEPTION()) {
                        goto ruleHEXINTEx;
                    }


                }
                break;

                default:

                    if ( cnt4 >= 1 ) {
                        goto loop4;
                    }
                    /* mismatchedSetEx()
                     */
                    CONSTRUCTEX();
                    EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                    EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                    goto ruleHEXINTEx;
                }
                cnt4++;
            }
loop4: ;    /* Jump to here if this rule does not match */
        }

    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleHEXINTEx; /* Prevent compiler warnings */
ruleHEXINTEx:
    ;

}
// $ANTLR end HEXINT

//   Comes from: 127:5: ( ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | ( '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '-' )? ( '0' .. '9' )+ EXPONENT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOAT
 *
 * Looks to match the characters the constitute the token FLOAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOAT(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = FLOAT;


    {
        //  ColorSetDef.g:127:5: ( ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | ( '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '-' )? ( '0' .. '9' )+ EXPONENT )

        ANTLR3_UINT32 alt14;

        alt14 = 3;

        alt14 = cdfa14.predict(ctx, RECOGNIZER, ISTREAM, &cdfa14);
        if  (HASEXCEPTION()) {
            goto ruleFLOATEx;
        }

        switch (alt14) {
        case 1:
            // ColorSetDef.g:127:9: ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )?
        {

            // ColorSetDef.g:127:9: ( '-' )?
            {
                int alt5 = 2;
                switch ( LA(1) ) {
                case '-': {
                    alt5 = 1;
                }
                break;
                }

                switch (alt5) {
                case 1:
                    // ColorSetDef.g:127:9: '-'
                {
                    MATCHC('-');
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                }
            }
            // ColorSetDef.g:127:14: ( '0' .. '9' )+
            {
                int cnt6 = 0;

                for (;;) {
                    int alt6 = 2;
                    switch ( LA(1) ) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9': {
                        alt6 = 1;
                    }
                    break;

                    }

                    switch (alt6) {
                    case 1:
                        // ColorSetDef.g:127:15: '0' .. '9'
                    {
                        MATCHRANGE('0', '9');
                        if  (HASEXCEPTION()) {
                            goto ruleFLOATEx;
                        }


                    }
                    break;

                    default:

                        if ( cnt6 >= 1 ) {
                            goto loop6;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleFLOATEx;
                    }
                    cnt6++;
                }
loop6: ;    /* Jump to here if this rule does not match */
            }
            MATCHC('.');
            if  (HASEXCEPTION()) {
                goto ruleFLOATEx;
            }


            // ColorSetDef.g:127:30: ( '0' .. '9' )*

            for (;;) {
                int alt7 = 2;
                switch ( LA(1) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                    alt7 = 1;
                }
                break;

                }

                switch (alt7) {
                case 1:
                    // ColorSetDef.g:127:31: '0' .. '9'
                {
                    MATCHRANGE('0', '9');
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                default:
                    goto loop7; /* break out of the loop */
                    break;
                }
            }
loop7: ; /* Jump out to here if this rule does not match */


            // ColorSetDef.g:127:42: ( EXPONENT )?
            {
                int alt8 = 2;
                switch ( LA(1) ) {
                case 'E':
                case 'e': {
                    alt8 = 1;
                }
                break;
                }

                switch (alt8) {
                case 1:
                    // ColorSetDef.g:127:42: EXPONENT
                {
                    /* 127:42: EXPONENT */
                    mEXPONENT(ctx );
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                }
            }

        }
        break;
        case 2:
            // ColorSetDef.g:128:9: ( '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )?
        {

            // ColorSetDef.g:128:9: ( '-' )?
            {
                int alt9 = 2;
                switch ( LA(1) ) {
                case '-': {
                    alt9 = 1;
                }
                break;
                }

                switch (alt9) {
                case 1:
                    // ColorSetDef.g:128:9: '-'
                {
                    MATCHC('-');
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                }
            }
            MATCHC('.');
            if  (HASEXCEPTION()) {
                goto ruleFLOATEx;
            }

            // ColorSetDef.g:128:18: ( '0' .. '9' )+
            {
                int cnt10 = 0;

                for (;;) {
                    int alt10 = 2;
                    switch ( LA(1) ) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9': {
                        alt10 = 1;
                    }
                    break;

                    }

                    switch (alt10) {
                    case 1:
                        // ColorSetDef.g:128:19: '0' .. '9'
                    {
                        MATCHRANGE('0', '9');
                        if  (HASEXCEPTION()) {
                            goto ruleFLOATEx;
                        }


                    }
                    break;

                    default:

                        if ( cnt10 >= 1 ) {
                            goto loop10;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleFLOATEx;
                    }
                    cnt10++;
                }
loop10: ;   /* Jump to here if this rule does not match */
            }

            // ColorSetDef.g:128:30: ( EXPONENT )?
            {
                int alt11 = 2;
                switch ( LA(1) ) {
                case 'E':
                case 'e': {
                    alt11 = 1;
                }
                break;
                }

                switch (alt11) {
                case 1:
                    // ColorSetDef.g:128:30: EXPONENT
                {
                    /* 128:30: EXPONENT */
                    mEXPONENT(ctx );
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                }
            }

        }
        break;
        case 3:
            // ColorSetDef.g:129:9: ( '-' )? ( '0' .. '9' )+ EXPONENT
        {

            // ColorSetDef.g:129:9: ( '-' )?
            {
                int alt12 = 2;
                switch ( LA(1) ) {
                case '-': {
                    alt12 = 1;
                }
                break;
                }

                switch (alt12) {
                case 1:
                    // ColorSetDef.g:129:9: '-'
                {
                    MATCHC('-');
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                }
            }
            // ColorSetDef.g:129:14: ( '0' .. '9' )+
            {
                int cnt13 = 0;

                for (;;) {
                    int alt13 = 2;
                    switch ( LA(1) ) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9': {
                        alt13 = 1;
                    }
                    break;

                    }

                    switch (alt13) {
                    case 1:
                        // ColorSetDef.g:129:15: '0' .. '9'
                    {
                        MATCHRANGE('0', '9');
                        if  (HASEXCEPTION()) {
                            goto ruleFLOATEx;
                        }


                    }
                    break;

                    default:

                        if ( cnt13 >= 1 ) {
                            goto loop13;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleFLOATEx;
                    }
                    cnt13++;
                }
loop13: ;   /* Jump to here if this rule does not match */
            }
            /* 129:9: ( '-' )? ( '0' .. '9' )+ EXPONENT */
            mEXPONENT(ctx );
            if  (HASEXCEPTION()) {
                goto ruleFLOATEx;
            }


        }
        break;

        }
    }
    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLOATEx; /* Prevent compiler warnings */
ruleFLOATEx:
    ;

}
// $ANTLR end FLOAT

//   Comes from: 133:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = COMMENT;


    {
        //  ColorSetDef.g:133:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/*' ( options {greedy=false; } : . )* '*/' )

        ANTLR3_UINT32 alt18;

        alt18 = 2;

        switch ( LA(1) ) {
        case '/': {
            switch ( LA(2) ) {
            case '/': {
                alt18 = 1;
            }
            break;
            case '*': {
                alt18 = 2;
            }
            break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 1;


                goto ruleCOMMENTEx;
            }

        }
        break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 18;
            EXCEPTION->state        = 0;


            goto ruleCOMMENTEx;
        }

        switch (alt18) {
        case 1:
            // ColorSetDef.g:133:9: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
        {
            MATCHS(lit_9);
            if  (HASEXCEPTION()) {
                goto ruleCOMMENTEx;
            }



            // ColorSetDef.g:133:14: (~ ( '\\n' | '\\r' ) )*

            for (;;) {
                int alt15 = 2;
                {
                    /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                     */
                    int LA15_0 = LA(1);
                    if ( (((LA15_0 >= 0x0000) && (LA15_0 <= '\t')) || ((LA15_0 >= 0x000B) && (LA15_0 <= '\f')) || ((LA15_0 >= 0x000E) && (LA15_0 <= 0xFFFF)))) {
                        alt15 = 1;
                    }

                }
                switch (alt15) {
                case 1:
                    // ColorSetDef.g:133:14: ~ ( '\\n' | '\\r' )
                {
                    if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) ) {
                        CONSUME();

                    } else {
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                        EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                        LRECOVER();
                        goto ruleCOMMENTEx;
                    }


                }
                break;

                default:
                    goto loop15;    /* break out of the loop */
                    break;
                }
            }
loop15: ; /* Jump out to here if this rule does not match */


            // ColorSetDef.g:133:28: ( '\\r' )?
            {
                int alt16 = 2;
                switch ( LA(1) ) {
                case '\r': {
                    alt16 = 1;
                }
                break;
                }

                switch (alt16) {
                case 1:
                    // ColorSetDef.g:133:28: '\\r'
                {
                    MATCHC('\r');
                    if  (HASEXCEPTION()) {
                        goto ruleCOMMENTEx;
                    }


                }
                break;

                }
            }
            MATCHC('\n');
            if  (HASEXCEPTION()) {
                goto ruleCOMMENTEx;
            }

            {
                LEXSTATE->channel = HIDDEN;
            }

        }
        break;
        case 2:
            // ColorSetDef.g:134:9: '/*' ( options {greedy=false; } : . )* '*/'
        {
            MATCHS(lit_10);
            if  (HASEXCEPTION()) {
                goto ruleCOMMENTEx;
            }



            // ColorSetDef.g:134:14: ( options {greedy=false; } : . )*

            for (;;) {
                int alt17 = 2;
                {
                    /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                     */
                    int LA17_0 = LA(1);
                    if ( (LA17_0 == '*')) {
                        {
                            /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                             */
                            int LA17_1 = LA(2);
                            if ( (LA17_1 == '/')) {
                                alt17 = 2;
                            } else if ( (((LA17_1 >= 0x0000) && (LA17_1 <= '.')) || ((LA17_1 >= '0') && (LA17_1 <= 0xFFFF)))) {
                                alt17 = 1;
                            }

                        }
                    } else if ( (((LA17_0 >= 0x0000) && (LA17_0 <= ')')) || ((LA17_0 >= '+') && (LA17_0 <= 0xFFFF)))) {
                        alt17 = 1;
                    }

                }
                switch (alt17) {
                case 1:
                    // ColorSetDef.g:134:42: .
                {
                    MATCHANY();
                    if  (HASEXCEPTION()) {
                        goto ruleCOMMENTEx;
                    }


                }
                break;

                default:
                    goto loop17;    /* break out of the loop */
                    break;
                }
            }
loop17: ; /* Jump out to here if this rule does not match */

            MATCHS(lit_11);
            if  (HASEXCEPTION()) {
                goto ruleCOMMENTEx;
            }


            {
                LEXSTATE->channel = HIDDEN;
            }

        }
        break;

        }
    }
    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
ruleCOMMENTEx:
    ;

}
// $ANTLR end COMMENT

//   Comes from: 137:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWS(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = WS;


    // ColorSetDef.g:137:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
    // ColorSetDef.g:137:9: ( ' ' | '\\t' | '\\r' | '\\n' )
    {
        if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || LA(1) == '\r' || LA(1) == ' ' ) {
            CONSUME();

        } else {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWSEx;
        }

        {
            LEXSTATE->channel = HIDDEN;
        }

    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
ruleWSEx:
    ;

}
// $ANTLR end WS

//   Comes from: 145:5: ( '\\'' ( ESC_SEQ | ~ ( '\\\\' | '\\'' ) )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING
 *
 * Looks to match the characters the constitute the token STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = STRING;


    // ColorSetDef.g:145:5: ( '\\'' ( ESC_SEQ | ~ ( '\\\\' | '\\'' ) )* '\\'' )
    // ColorSetDef.g:145:8: '\\'' ( ESC_SEQ | ~ ( '\\\\' | '\\'' ) )* '\\''
    {
        MATCHC('\'');
        if  (HASEXCEPTION()) {
            goto ruleSTRINGEx;
        }


        // ColorSetDef.g:145:13: ( ESC_SEQ | ~ ( '\\\\' | '\\'' ) )*

        for (;;) {
            int alt19 = 3;
            {
                /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                 */
                int LA19_0 = LA(1);
                if ( (LA19_0 == '\\')) {
                    alt19 = 1;
                } else if ( (((LA19_0 >= 0x0000) && (LA19_0 <= '&')) || ((LA19_0 >= '(') && (LA19_0 <= '[')) || ((LA19_0 >= ']') && (LA19_0 <= 0xFFFF)))) {
                    alt19 = 2;
                }

            }
            switch (alt19) {
            case 1:
                // ColorSetDef.g:145:15: ESC_SEQ
            {
                /* 145:15: ESC_SEQ */
                mESC_SEQ(ctx );
                if  (HASEXCEPTION()) {
                    goto ruleSTRINGEx;
                }


            }
            break;
            case 2:
                // ColorSetDef.g:145:25: ~ ( '\\\\' | '\\'' )
            {
                if ( ((LA(1) >= 0x0000) && (LA(1) <= '&')) || ((LA(1) >= '(') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) ) {
                    CONSUME();

                } else {
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                    EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                    LRECOVER();
                    goto ruleSTRINGEx;
                }


            }
            break;

            default:
                goto loop19;    /* break out of the loop */
                break;
            }
        }
loop19: ; /* Jump out to here if this rule does not match */

        MATCHC('\'');
        if  (HASEXCEPTION()) {
            goto ruleSTRINGEx;
        }


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRINGEx; /* Prevent compiler warnings */
ruleSTRINGEx:
    ;

}
// $ANTLR end STRING

//   Comes from: 149:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXPONENT(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;


    // ColorSetDef.g:149:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
    // ColorSetDef.g:149:12: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
    {
        if ( LA(1) == 'E' || LA(1) == 'e' ) {
            CONSUME();

        } else {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEXPONENTEx;
        }


        // ColorSetDef.g:149:22: ( '+' | '-' )?
        {
            int alt20 = 2;
            switch ( LA(1) ) {
            case '+':
            case '-': {
                alt20 = 1;
            }
            break;
            }

            switch (alt20) {
            case 1:
                // ColorSetDef.g:
            {
                if ( LA(1) == '+' || LA(1) == '-' ) {
                    CONSUME();

                } else {
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                    EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                    LRECOVER();
                    goto ruleEXPONENTEx;
                }


            }
            break;

            }
        }
        // ColorSetDef.g:149:33: ( '0' .. '9' )+
        {
            int cnt21 = 0;

            for (;;) {
                int alt21 = 2;
                switch ( LA(1) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                    alt21 = 1;
                }
                break;

                }

                switch (alt21) {
                case 1:
                    // ColorSetDef.g:149:34: '0' .. '9'
                {
                    MATCHRANGE('0', '9');
                    if  (HASEXCEPTION()) {
                        goto ruleEXPONENTEx;
                    }


                }
                break;

                default:

                    if ( cnt21 >= 1 ) {
                        goto loop21;
                    }
                    /* mismatchedSetEx()
                     */
                    CONSTRUCTEX();
                    EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                    EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                    goto ruleEXPONENTEx;
                }
                cnt21++;
            }
loop21: ;   /* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleEXPONENTEx; /* Prevent compiler warnings */
ruleEXPONENTEx:
    ;

}
// $ANTLR end EXPONENT

//   Comes from: 152:11: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_DIGIT
 *
 * Looks to match the characters the constitute the token HEX_DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_DIGIT(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;


    // ColorSetDef.g:152:11: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
    // ColorSetDef.g:152:13: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) ) {
            CONSUME();

        } else {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHEX_DIGITEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleHEX_DIGITEx; /* Prevent compiler warnings */
ruleHEX_DIGITEx:
    ;

}
// $ANTLR end HEX_DIGIT

//   Comes from: 156:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESC | OCTAL_ESC )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ESC_SEQ
 *
 * Looks to match the characters the constitute the token ESC_SEQ
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mESC_SEQ(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;


    {
        //  ColorSetDef.g:156:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESC | OCTAL_ESC )

        ANTLR3_UINT32 alt22;

        alt22 = 3;

        switch ( LA(1) ) {
        case '\\': {
            switch ( LA(2) ) {
            case '"':
            case '\'':
            case '\\':
            case 'b':
            case 'f':
            case 'n':
            case 'r':
            case 't': {
                alt22 = 1;
            }
            break;
            case 'u': {
                alt22 = 2;
            }
            break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7': {
                alt22 = 3;
            }
            break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 1;


                goto ruleESC_SEQEx;
            }

        }
        break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 22;
            EXCEPTION->state        = 0;


            goto ruleESC_SEQEx;
        }

        switch (alt22) {
        case 1:
            // ColorSetDef.g:156:9: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' )
        {
            MATCHC('\\');
            if  (HASEXCEPTION()) {
                goto ruleESC_SEQEx;
            }

            if ( LA(1) == '"' || LA(1) == '\'' || LA(1) == '\\' || LA(1) == 'b' || LA(1) == 'f' || LA(1) == 'n' || LA(1) == 'r' || LA(1) == 't' ) {
                CONSUME();

            } else {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                LRECOVER();
                goto ruleESC_SEQEx;
            }


        }
        break;
        case 2:
            // ColorSetDef.g:157:9: UNICODE_ESC
        {
            /* 157:9: UNICODE_ESC */
            mUNICODE_ESC(ctx );
            if  (HASEXCEPTION()) {
                goto ruleESC_SEQEx;
            }


        }
        break;
        case 3:
            // ColorSetDef.g:158:9: OCTAL_ESC
        {
            /* 158:9: OCTAL_ESC */
            mOCTAL_ESC(ctx );
            if  (HASEXCEPTION()) {
                goto ruleESC_SEQEx;
            }


        }
        break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleESC_SEQEx; /* Prevent compiler warnings */
ruleESC_SEQEx:
    ;

}
// $ANTLR end ESC_SEQ

//   Comes from: 163:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OCTAL_ESC
 *
 * Looks to match the characters the constitute the token OCTAL_ESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOCTAL_ESC(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;


    {
        //  ColorSetDef.g:163:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )

        ANTLR3_UINT32 alt23;

        alt23 = 3;

        switch ( LA(1) ) {
        case '\\': {
            switch ( LA(2) ) {
            case '0':
            case '1':
            case '2':
            case '3': {
                switch ( LA(3) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7': {
                    switch ( LA(4) ) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7': {
                        alt23 = 1;
                    }
                    break;

                    default:
                        alt23 = 2;
                    }

                }
                break;

                default:
                    alt23 = 3;
                }

            }
            break;
            case '4':
            case '5':
            case '6':
            case '7': {
                switch ( LA(3) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7': {
                    alt23 = 2;
                }
                break;

                default:
                    alt23 = 3;
                }

            }
            break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 23;
                EXCEPTION->state        = 1;


                goto ruleOCTAL_ESCEx;
            }

        }
        break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 23;
            EXCEPTION->state        = 0;


            goto ruleOCTAL_ESCEx;
        }

        switch (alt23) {
        case 1:
            // ColorSetDef.g:163:9: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
        {
            MATCHC('\\');
            if  (HASEXCEPTION()) {
                goto ruleOCTAL_ESCEx;
            }

            // ColorSetDef.g:163:14: ( '0' .. '3' )
            // ColorSetDef.g:163:15: '0' .. '3'
            {
                MATCHRANGE('0', '3');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }

            // ColorSetDef.g:163:25: ( '0' .. '7' )
            // ColorSetDef.g:163:26: '0' .. '7'
            {
                MATCHRANGE('0', '7');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }

            // ColorSetDef.g:163:36: ( '0' .. '7' )
            // ColorSetDef.g:163:37: '0' .. '7'
            {
                MATCHRANGE('0', '7');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }


        }
        break;
        case 2:
            // ColorSetDef.g:164:9: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
        {
            MATCHC('\\');
            if  (HASEXCEPTION()) {
                goto ruleOCTAL_ESCEx;
            }

            // ColorSetDef.g:164:14: ( '0' .. '7' )
            // ColorSetDef.g:164:15: '0' .. '7'
            {
                MATCHRANGE('0', '7');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }

            // ColorSetDef.g:164:25: ( '0' .. '7' )
            // ColorSetDef.g:164:26: '0' .. '7'
            {
                MATCHRANGE('0', '7');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }


        }
        break;
        case 3:
            // ColorSetDef.g:165:9: '\\\\' ( '0' .. '7' )
        {
            MATCHC('\\');
            if  (HASEXCEPTION()) {
                goto ruleOCTAL_ESCEx;
            }

            // ColorSetDef.g:165:14: ( '0' .. '7' )
            // ColorSetDef.g:165:15: '0' .. '7'
            {
                MATCHRANGE('0', '7');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }


        }
        break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleOCTAL_ESCEx; /* Prevent compiler warnings */
ruleOCTAL_ESCEx:
    ;

}
// $ANTLR end OCTAL_ESC

//   Comes from: 170:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNICODE_ESC
 *
 * Looks to match the characters the constitute the token UNICODE_ESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNICODE_ESC(pColorSetDefLexer ctx)
{
    ANTLR3_UINT32   _type;


    // ColorSetDef.g:170:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
    // ColorSetDef.g:170:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
    {
        MATCHC('\\');
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }

        MATCHC('u');
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }

        /* 170:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }

        /* 170:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }

        /* 170:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }

        /* 170:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleUNICODE_ESCEx; /* Prevent compiler warnings */
ruleUNICODE_ESCEx:
    ;

}
// $ANTLR end UNICODE_ESC

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void
mTokens(pColorSetDefLexer ctx)
{
    {
        //  ColorSetDef.g:1:8: ( T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | ID | INT | HEXINT | FLOAT | COMMENT | WS | STRING )

        ANTLR3_UINT32 alt24;

        alt24 = 20;

        alt24 = cdfa24.predict(ctx, RECOGNIZER, ISTREAM, &cdfa24);
        if  (HASEXCEPTION()) {
            goto ruleTokensEx;
        }

        switch (alt24) {
        case 1:
            // ColorSetDef.g:1:10: T__16
        {
            /* 1:10: T__16 */
            mT__16(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 2:
            // ColorSetDef.g:1:16: T__17
        {
            /* 1:16: T__17 */
            mT__17(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 3:
            // ColorSetDef.g:1:22: T__18
        {
            /* 1:22: T__18 */
            mT__18(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 4:
            // ColorSetDef.g:1:28: T__19
        {
            /* 1:28: T__19 */
            mT__19(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 5:
            // ColorSetDef.g:1:34: T__20
        {
            /* 1:34: T__20 */
            mT__20(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 6:
            // ColorSetDef.g:1:40: T__21
        {
            /* 1:40: T__21 */
            mT__21(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 7:
            // ColorSetDef.g:1:46: T__22
        {
            /* 1:46: T__22 */
            mT__22(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 8:
            // ColorSetDef.g:1:52: T__23
        {
            /* 1:52: T__23 */
            mT__23(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 9:
            // ColorSetDef.g:1:58: T__24
        {
            /* 1:58: T__24 */
            mT__24(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 10:
            // ColorSetDef.g:1:64: T__25
        {
            /* 1:64: T__25 */
            mT__25(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 11:
            // ColorSetDef.g:1:70: T__26
        {
            /* 1:70: T__26 */
            mT__26(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 12:
            // ColorSetDef.g:1:76: T__27
        {
            /* 1:76: T__27 */
            mT__27(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 13:
            // ColorSetDef.g:1:82: T__28
        {
            /* 1:82: T__28 */
            mT__28(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 14:
            // ColorSetDef.g:1:88: ID
        {
            /* 1:88: ID */
            mID(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 15:
            // ColorSetDef.g:1:91: INT
        {
            /* 1:91: INT */
            mINT(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 16:
            // ColorSetDef.g:1:95: HEXINT
        {
            /* 1:95: HEXINT */
            mHEXINT(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 17:
            // ColorSetDef.g:1:102: FLOAT
        {
            /* 1:102: FLOAT */
            mFLOAT(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 18:
            // ColorSetDef.g:1:108: COMMENT
        {
            /* 1:108: COMMENT */
            mCOMMENT(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 19:
            // ColorSetDef.g:1:116: WS
        {
            /* 1:116: WS */
            mWS(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 20:
            // ColorSetDef.g:1:119: STRING
        {
            /* 1:119: STRING */
            mSTRING(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx:
    ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */


/* End of code
 * =============================================================================
 */
